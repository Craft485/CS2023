##Lab04 Required Questions ##

#########
# Lists #
#########

_author_ = "Colin Davis"
_credits_ = []
_email_ = "davis7cl@mail.uc.edu"

# RQ1
def cascade(lst: list[int]):
    """Returns the cascade of the given list running forward and back.

    >>> cascade([1, 2, 3, 4])
    [1, 2, 3, 4, 4, 3, 2, 1]
    """
    return [*lst, *(lst[::-1])] # Return a new list made of the contents of the original plus the contents of the reversed instance of the original list

# RQ2
def maptwice(fn, seq: list[int]):
    """Applies fn twice onto each element in seq and returns the resulting list.

    >>> maptwice(lambda x: x*x, [1, 2, 3])
    [1, 16, 81]
    """
    return [fn(fn(x)) for x in seq] # Return a new list generated by passing x to fn, then passing that result to fn again, for each item in the list

#RQ3
def filterout(pred, seq: list[int]):
    """Keeps elements in seq only if they do not satisfy pred.

    >>> filterout(lambda x: x % 2 == 0, [1, 2, 3, 4])
    [1, 3]
    """
    return [x for x in seq if not pred(x)] # Return a new list that contains elements of the original list that do not meet the condition

#RQ4
def comp(n: int, pred):
    """ Uses a one line list comprehension to return list of the first n integers (0...n-1) which satisfy the predicate pred.
    >>> comp(7, lambda x: x%2 ==0)
    [0, 2, 4, 6]
    """
    return [x for x in range(n) if pred(x)] # Generate a list of ints from 0-n that match the predicate

#RQ5
def flatten(lst: list) -> list[int]:
    """ Takes a nested list and "flattens" it.
    
    >>> flatten([1, 2, 3]) 
    [1, 2, 3]
    >>> x = [1, [2, 3], 4]      
    >>> flatten(x)
    [1, 2, 3, 4]
    >>> x = [[1, [1, 1]], 1, [1, 1]] 
    >>> flatten(x)
    [1, 1, 1, 1, 1, 1]
    >>> lst = [1, [[2], 3], 4, [5, 6]]
    >>> flatten(lst)
    [1, 2, 3, 4, 5, 6]
    """
    result = []
    for x in lst:
        if isinstance(x, int): # If the currently element is already an int, we don't need to flatten it
            result.append(x)
        else:
            for x2 in flatten(x): # Recursively flatten any lists we encounter
                result.append(x2)
    return result

import doctest
if __name__ == "__main__":
    doctest.testmod(verbose=True)
